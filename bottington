local queue_on_teleport = queue_on_teleport
local StarterGui = game:GetService("StarterGui")
local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
local brainrotImages = loadstring(game:HttpGet("https://pastebin.com/raw/i0AJf9G9"))()
local Service = game:GetService("HttpService")
local serverUrl = "https://myscript-4zvx.onrender.com"
local hubName = "Garof ServerHopper" -- idk it ain a hub lmao
local Testing = false

if started and not Testing then
	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = function(button)
		if button == "Yes" then
			game["Teleport Service"]:Teleport(game.PlaceId, game.Players.LocalPlayer)
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "The script is already running!",
		Text = "Teleport to start?",
		Duration = 5,
		Button1 = "Yes",
		Button2 = "No",
		Callback = bindable
	})
	return 
end
pcall(function() getgenv().started = true end)

game.Players.LocalPlayer.OnTeleport:Connect(function(state)
	if state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.InProgress then return end

	queue_on_teleport([[
		print(1) -- rlly hope this doesnt break bro

		repeat
			task.wait()
		until game:IsLoaded() and game.Players.LocalPlayer and game.Players.LocalPlayer.Character

		print(2)

		task.wait(2)

		print(3)

		local url = "https://raw.githubusercontent.com/majdnakhleh92/very-cool/refs/heads/main/bottington"
		local StarterGui = game:GetService("StarterGui")
		local SoundService = game:GetService("SoundService")
		local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()

		local func, err = pcall(function()
			loadstring(game:HttpGet(url))()
		end)

		if not func then
			print(err)
			StarterGui:SetCore("SendNotification", {
				Title = "SOMETHING WENT WRONG!!!",
				Text = "somethingwentwrong",
				Duration = 5
			})

			local sound = Instance.new("Sound")
			sound.SoundId = "rbxassetid://4881487887"
			sound.Volume = 0.5
			sound.Looped = false
			sound.Parent = SoundService
			sound:Play()
			getgenv().started = false
			local msg = ""
			if err == 'http error occured: "HTTP/1.1 429 Too Many Requests"' then
				msg = "Lower the teleport delay!"
			end
			
			local myMessage = webhookUtil.createMessage({
				Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
				username = "Script Logs",
				content = msg 
			})

			local embed1 = myMessage.addEmbed(
				"error occured",
				0x57F287,
				err,
				nil,
				nil
			)

			myMessage.sendMessage()
		end
    ]])
end)

local Settings = {}
local Bots = {}

makefolder(hubName)

function SaveSettings()
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

function LoadSettings()
	if isfile(hubName .. "\\configName.cfg") then
		local success, result = pcall(function() return Service:JSONDecode(readfile(hubName .. "\\configName.cfg")) end)
		if success then Settings = result end
	end
end

function SaveBots()
	local JSON = Service:JSONEncode(Bots)
	writefile(hubName .. "\\Bots.cfg", JSON)
end

function LoadBots()
	if isfile(hubName .. "\\Bots.cfg") then
		local success, result = pcall(function() return Service:JSONDecode(readfile(hubName .. "\\Bots.cfg")) end)
		if success then Bots = result end
	end
end

LoadSettings()
LoadBots()

function ResetSettings()
	Settings["Server Count"] = 0
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

local function GetBrainrotUrl(name)
	local brainrotImage = brainrotImages[name]
	if brainrotImage then
		return brainrotImage
	end
	return nil
end

local function GetJoinLink()
	return string.format("https://www.roblox.com/games/start?placeId=%s&gameInstanceId=%s", game.PlaceId, game.JobId)
end

local function ReturnPingRoles(tbl)
	local total = 0
	for _, s in ipairs(tbl) do
		local num = s:match("%$([%d%.]+)M")
		if num then
			total = total + tonumber(num)
		end
	end
	if not total then return end
	
	if total < 100 then
		return
	elseif total < 500 then
		return "<@1476593217599439012> "
	elseif total > 1000 then
		return "<@1476593217599439012> <@1476593349841391828> "
	end
end

local function DiscordNotificationCURRENCY(txtlbl, temp)

	local ovrhead = txtlbl.Parent
	local playerName = game.Players.LocalPlayer.Name
	local bestDisplayName = ovrhead:FindFirstChild("DisplayName")
	local bestgen = ovrhead:FindFirstChild("Generation")

	local description = "**⚠︎ Other Brainrots**\n```" .. table.concat(temp, "\n") .. "```"
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh?wait=true",
		username = "Script Logs",
		content = ReturnPingRoles(temp) .. "A good server found by: " .. playerName
	})

	local embed1 = myMessage.addEmbed(
		bestDisplayName.Text .. " " .. bestgen.Text,
		Settings["embedColor"] or 0x57F287,
		description,
		nil,
		GetBrainrotUrl(bestDisplayName.Text)
	)

	
	embed1.addField("Join Link", "[Click Here To join](" .. GetJoinLink() .. ")", false)
	
	local response = myMessage.sendMessage()
	local body = Service:JSONDecode(response.Body)
	ResetSettings()
	return body
end

local blacklist = Settings["Blacklist"] or {"La Grande Combinasion", "Los Nooo My Hotspotsitos", "Bunito Bunito Spinito", "Horegini Boom", "Lucky Block", "Giftini Spyderini", "Santa Hotspot", "Naughty Naughty", "Los Cucarachas", "La Cucaracha", "Pot Hotspot", "Los 25", "Ho Ho Ho Sahur", "To to to Sahur", "Chimnino", "Graipuss Medussi", "Rocco Disco", "Triplito Tralaleritos", "La Vacca Prese Presente", "Los Tralaleritos", "Guerriro Digitale", "Noo my Present", "Las Tralaleritas", "Los Tortus", "Job Job Job Sahur", "Los Burritos", "Los Jobcitos", "Burrito Bandito", "Quesadilla Crocodila", "Los Quesadillas", "Tung Tung Tung Sahur", "Cuadramat and Pakrahmatmamat", "List List List Sahur", "Chicleteirina Bicicleteirina"}
local Priority = Settings["Whitelist"] or {"Nooo my Hotspot", "Raccooni Jandelini", "Quesadillo Vampiro"}

local function GetAnimalOverhead()
	local animalOverheadTable = {}

	for _, SurfaceGui in pairs(workspace.Debris:GetDescendants()) do
		if SurfaceGui:IsA("SurfaceGui") and SurfaceGui.Name == "AnimalOverhead" then
			table.insert(animalOverheadTable, SurfaceGui)
		end
	end

	return animalOverheadTable
end

local function GetPlayerNameFromLabel(textLabel)
	if not textLabel or not textLabel:IsA("TextLabel") or not textLabel.Text then
		return nil
	end

	local text = textLabel.Text
	local playerName = string.match(text, "^(.+)'s Base$")

	if playerName then
		for _, PLR in pairs(game.Players:GetPlayers()) do
			if PLR.Name == playerName or PLR.DisplayName == playerName then
				return PLR
			end
		end
		return nil
	else

		if string.match(text, "^Empty Base$") then
			return nil
		else

			warn("Unexpected base label format: " .. text)
			return nil
		end
	end
end

local function HasOwner(part)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {part}

	local raycast = workspace:Raycast(part.Position, Vector3.new(0, -100, 0), params)
	if raycast and raycast.Instance then

		for _, Plot in workspace.Plots:GetChildren() do
			if raycast.Instance:IsDescendantOf(Plot) then
				if not Plot:FindFirstChild("PlotSign") then continue end
				if not Plot.PlotSign:FindFirstChild("SurfaceGui") then continue end
				if not Plot.PlotSign.SurfaceGui:FindFirstChild("Frame") then continue end
				if not Plot.PlotSign.SurfaceGui.Frame:FindFirstChild("TextLabel") then continue end

				return GetPlayerNameFromLabel(Plot.PlotSign.SurfaceGui.Frame.TextLabel)
			end
		end
	else 
		return nil
	end
end

local function GetMostValuable(strings, minimum)
	local bestValue = -math.huge
	local bestTextLabel = nil
	local bestString = nil
	local minimumMetTextLabels = {}

	for _, txtlbl in ipairs(strings) do
		local str = txtlbl.Text
		local number, suffix = string.match(str:lower(), "^%s*%$?(%d*%.?%d+)%s*([kmb]?)%s*/?s?$")
		if number then
			local value = tonumber(number)
			if value then
				if suffix == "k" then
					value = value * 1_000
				elseif suffix == "m" then
					value = value * 1_000_000
				elseif suffix == "b" then
					value = value * 1_000_000_000
				end
				if value > bestValue then
					bestValue = value
					bestTextLabel = txtlbl
					bestString = str
					print("Valid currency string: " .. str .. " -> Value: " .. value)
				end
				if value >= minimum then
					table.insert(minimumMetTextLabels, {label = txtlbl, value = value})
				end
			end
		else
			print("Skipped non-currency string: " .. str)
		end
	end

	if bestValue == -math.huge then
		print("No valid currency strings found")
		return false, nil, nil, {}
	end

	table.sort(minimumMetTextLabels, function(a, b)
		return a.value > b.value
	end)

	local temp = {}
	for _, entry in ipairs(minimumMetTextLabels) do
		local generation = entry.label.Text
		local overhead = entry.label.Parent
		local dpName = overhead.DisplayName
		table.insert(temp, dpName.Text .. " (" .. generation .. ")")
	end

	local meetsMinimum = bestValue >= minimum
	local owner = HasOwner(bestTextLabel.Parent.Parent)
	print(string.format("Highest value: %d, Minimum: %d, Meets minimum: %s", bestValue, minimum, tostring(meetsMinimum)))

	return meetsMinimum, bestTextLabel, bestString, temp, owner
end

local function CheckCurrency(minimum)
	local valuetable = {}
	local AnimalOverheadTabel = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTabel) do
		local Stolen = overhead:FindFirstChild("Stolen")
		local displayName = overhead:FindFirstChild("DisplayName")
		local gen = overhead:FindFirstChild("Generation")
		local owner = HasOwner(overhead.Parent)

		if not owner then print("no owner buster") continue end
		local illegalNames = {"IN DUEL", "FUSING", "READY!"}
		if Stolen and table.find(illegalNames, Stolen.Text) and Stolen.Visible == true then 
			continue 
		end

		if not gen then continue end
		if displayName and table.find(blacklist, displayName.Text) then 
			print("Blacklisted: " .. displayName.Text)
			continue 
		end

		table.insert(valuetable, gen)
	end

	local meetsMinimum, textlabel, amount, minimumMetTextLabels, owner = GetMostValuable(valuetable, minimum)
	return meetsMinimum, amount, textlabel, minimumMetTextLabels, owner
end

local function AddServer(bestBrainrotData)
	local success, result = pcall(function()
		return request({
			Url = serverUrl .. "/get-servers",
			Method = "GET"
		})
	end)

	local servers = {}
	if success and result.StatusCode == 200 then
		local data = Service:JSONDecode(result.Body)
		servers = data.servers or {}
		print("Existing servers:", Service:JSONEncode(servers))
	end

	servers[game.JobId] = {
		Time = os.time(),
		Brainrot = bestBrainrotData.Name,
		Generation = bestBrainrotData.Generation,
		bot = game.Players.LocalPlayer.Name
	}

	local result1 = request({
		Url = serverUrl .. "/post-server",
		Method = "POST",
		Headers = {["Content-Type"] = "application/json"},
		Body = Service:JSONEncode(servers)
	})
	print("Posted:", result1.Body)
end

local function RemoveServer()
	local success, result = pcall(function()
		return request({
			Url = serverUrl .. "/get-servers",
			Method = "GET"
		})
	end)

	local servers = {}
	if success and result.StatusCode == 200 then
		local data = Service:JSONDecode(result.Body)
		servers = data.servers or {}
	end

	servers[game.JobId] = nil

	local result1 = request({
		Url = serverUrl .. "/post-server",
		Method = "POST",
		Headers = {["Content-Type"] = "application/json"},
		Body = Service:JSONEncode(servers)
	})
	print("Posted:", result1.Body)
end

local function CloseBot()
	if close == true then
		local player = game.Players.LocalPlayer
		Bots[player.Name] = game.JobId
		Bots["Servers"] = {}
		SaveBots()
		RemoveServer()
		game:Shutdown()
	end
end

local function CheckIfClaimed()
	local JobId = game.JobId
	local player = game.Players.LocalPlayer

	if next(Bots) == nil then return true end

	for bot, server in Bots do
		if bot == player.Name and server == JobId then return true, "AlreadyClaimed" end
		if server == JobId then return false end
	end

	return true
end

local function CheckIfProccessed(brainrot, Table)
	if Table[brainrot] and (tick() - Table[brainrot]) < 300 then return true end
	return false
end

local function EditPlayerLeft(plr, body)
	if not plr or not body then return end
	local joinTime = os.time()
	local webhookUrl = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh"

	local con
	con = game.Players.PlayerRemoving:Connect(function(removedPlr)
		if removedPlr ~= plr then return end
		con:Disconnect()
		RemoveServer()
		local duration = os.time() - joinTime
		body.embeds[1].color = 0xFF0000
		table.insert(body.embeds[1].fields, {
			name = "Player Has Left The Server",
			value = string.format("%dm %ds", math.floor(duration / 60), duration % 60),
			inline = false
		})
		
		pcall(function()
			request({
				Url = webhookUrl .. "/messages/" .. body.id,
				Method = "PATCH",
				Headers = {["Content-Type"] = "application/json"},
				Body = Service:JSONEncode({ embeds = body.embeds })
			})
		end)
	end)
end

local function Claim()
	local player = game.Players.LocalPlayer
	local boolean, check = CheckIfClaimed()
	if not boolean then return end
	if check and check == "AlreadyClaimed" then return end
	
	Bots[player.Name] = game.JobId
	SaveBots()
end

local function Serverhop()
	local Tried
	local HttpService, TeleportService, CoreGui = game:GetService("HttpService"), game:GetService("TeleportService"), game:GetService("CoreGui");
	local RemoveErrorPrompts = Settings["RemoveErrorPrompts"] or true --prevents error messages from popping up.
	local IterationSpeed = Settings["ServerhopSpeed"] or 0.30 --speed in which next server is picked for teleport (the higher it is the slower the teleports but more likely to work).
	local ExcludefullServers = Settings["ExcludefullServers"] or false --slightly beneficial if the game is high ccu or mid ccu, if not, set to false.
	local SaveTeleportAttempts = Settings["SaveTeleportAttempts"] or false --saves every teleports that are attempted in jobid to "Attempts.txt" file
	local API = Settings["API"] or "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"

	if Testing then return end
	local function EncodeToFile(JSONString)
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(JSONString)
		end)
		if success and JSONData.data then
			JSONData.gameId = game.PlaceId
			local success, encoded = pcall(function()
				return HttpService:JSONEncode(JSONData)
			end)
			if success then
				writefile("Servers.JSON", encoded)
			else
				warn("Failed to encode JSON string.")
				return nil
			end
		else
			warn("Failed to decode JSONData.")
			return nil
		end
		return JSONData
	end

	local function NextCursor(ep)
		return game:HttpGet(API .. "&excludeFullGames=" .. tostring(ExcludefullServers) .. ((ep and "&cursor=" .. ep) or ""))
	end

	local function StartTeleport()
		Tried = true
		local JSONData = EncodeToFile(readfile("Servers.JSON"))
		if not JSONData then
			writefile("Servers.JSON", game:HttpGet(API))
			StartTeleport()
		end
		for i = 0, 99 do
			if #JSONData.data <= 1 then
				EncodeToFile(NextCursor(JSONData.nextPageCursor))
				TeleportService:Teleport(game.PlaceId, game.Players.LocalPlayer)
			end
			if JSONData.data[i] then
				local JobId = JSONData.data[i].id
				table.remove(JSONData.data, i)
				local sucess, encoded = pcall(function()
					return HttpService:JSONEncode(JSONData)
				end)
				writefile("Servers.JSON", encoded)
				if SaveTeleportAttempts then
					appendfile("Attempts.txt", JobId .. "\n")
				end
				TeleportService:TeleportToPlaceInstance(game.PlaceId, JobId, game.Players.LocalPlayer)
				task.wait(IterationSpeed)
			end
		end
	end

	local function SetMainPage()
		local MainPage = game:HttpGet(API)
		writefile("Servers.JSON", MainPage)
		StartTeleport()
	end

	if RemoveErrorPrompts then 
		local RG = CoreGui:FindFirstChild("RobloxGui")
		local M = RG and RG:FindFirstChild("Modules")
		local EP = M and M:FindFirstChild("ErrorPrompt")

		if EP then
			EP:Destroy()
		end

		local RPG = CoreGui:FindFirstChild("RobloxPromptGui")
		if RPG then
			RPG:Destroy()
		end
	end

	if isfile("Servers.JSON") then
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(readfile("Servers.JSON"))
		end)
		if success and JSONData then
			if JSONData.gameId ~= game.PlaceId then
				warn("Game mismatch from cache, remaking cache for --> " .. game.PlaceId)
				SetMainPage()
			end
			if JSONData.data and #JSONData.data >= 1 then
				StartTeleport()
			else
				if success and JSONData.nextPageCursor then
					EncodeToFile(NextCursor(JSONData.nextPageCursor))
					StartTeleport()
				else
					SetMainPage()
				end
			end
		else
			SetMainPage()
		end
	else
		SetMainPage()
	end

	if Tried then
		print("yaaaaaaaaaaaaaaaaaaaaa")
		Serverhop()
	end
end

local minimum = tonumber(Settings["MoneyPerSecond"]) or 10_000_000
local mainScript = Settings["HubtoLoad"] or "https://raw.githubusercontent.com/ily123950/Vulkan/refs/heads/main/Tr"
local Proccessed = {}
while task.wait(math.random(2, 4)) do
	LoadBots()
	CloseBot()
	local player = game.Players.LocalPlayer
	local Claimed = CheckIfClaimed()
	if Claimed then
		local meetsMinimum, highestAmount, currencyTextLabel, temp, owner = CheckCurrency(minimum)
		if meetsMinimum then
			local tbl =  {}
			for _, v in temp do
				local proccessed = CheckIfProccessed(v, Proccessed)
				if proccessed then continue end
				table.insert(tbl, v)
				Proccessed[v] = tick()
			end
			if next(tbl) == nil then continue end
			if not Bots["Servers"] then Bots["Servers"] = {} end
			Bots["Servers"][game.JobId] = os.time()
			SaveBots()
			AddServer({Name = currencyTextLabel.Parent:FindFirstChild("DisplayName").Text, Generation = currencyTextLabel.Parent:FindFirstChild("Generation").Text})
			local body = DiscordNotificationCURRENCY(currencyTextLabel, tbl)
			EditPlayerLeft(owner, body)
		end
	else
		Bots[player.Name] = nil
		SaveBots()
		Serverhop()
	end
end
