local queue_on_teleport = queue_on_teleport
local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
local brainrotImages = loadstring(game:HttpGet("https://pastebin.com/raw/i0AJf9G9"))()
print("[DEBUG] script started")

game.Players.LocalPlayer.OnTeleport:Connect(function(state)
    print("[DEBUG] OnTeleport triggered - state:", state.Name)
    if state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.InProgress then 
        print("[DEBUG] Ignoring state")
        return 
    end
    print("[DEBUG] Queueing on teleport")
    queue_on_teleport([[
        print("[DEBUG QUEUED] 1")
        repeat
            task.wait()
        until game:IsLoaded() and game.Players.LocalPlayer and game.Players.LocalPlayer.Character
        print("[DEBUG QUEUED] 2")
        task.wait(3)
        print("[DEBUG QUEUED] 3")
        local url = "https://raw.githubusercontent.com/majdnakhleh92/very-cool/refs/heads/main/bottington"
        local StarterGui = game:GetService("StarterGui")
        local func, err = pcall(function()
            loadstring(game:HttpGet(url))()
        end)
        if not func then
            print("[DEBUG QUEUED ERROR]", err)
            StarterGui:SetCore("SendNotification", {
                Title = "SOMETHING WENT WRONG!!!",
                Text = "somethingwentwrong",
                Duration = 5
            })
        else
            print("[DEBUG QUEUED] Bottington loaded ok")
        end
    ]])
end)

local function GetPlayerNameFromLabel(textLabel)
    print("[DEBUG] GetPlayerNameFromLabel called - text:", textLabel and textLabel.Text or "nil")
    if not textLabel or not textLabel:IsA("TextLabel") or not textLabel.Text then
        return nil
    end
    local text = textLabel.Text
    local playerName = string.match(text, "^(.+)'s Base$")
    if playerName then
        print("[DEBUG] Matched playerName:", playerName)
        for _, PLR in pairs(game.Players:GetPlayers()) do
            if PLR.Name == playerName or PLR.DisplayName == playerName then
                print("[DEBUG] Found player:", PLR.Name)
                return PLR
            end
        end
        print("[DEBUG] No player found for name")
        return nil
    else
        if string.match(text, "^Empty Base$") then
            print("[DEBUG] Empty Base")
            return nil
        else
            warn("[DEBUG] Unexpected base label format: " .. text)
            return nil
        end
    end
end

local function GetBrainrotUrl(name)
    print("[DEBUG] GetBrainrotUrl for:", name)
    local brainrotImage = brainrotImages[name]
    if brainrotImage then
        print("[DEBUG] Found URL:", brainrotImage)
        return brainrotImage
    end
    print("[DEBUG] No URL found")
    return nil
end

local function DiscordNotificationCURRENCY(txtlbl)
    print("[DEBUG] DiscordNotificationCURRENCY called")
    local ovrhead = txtlbl.Parent
    local DisplayName = ovrhead:FindFirstChild("DisplayName")
    local gen = ovrhead:FindFirstChild("Generation")
    print("[DEBUG] DisplayName:", DisplayName and DisplayName.Text or "nil", "Gen:", gen and gen.Text or "nil")
    local myMessage = webhookUtil.createMessage({
        Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
        username = "Script Logs",
        content = "A good server found by: " .. game.Players.LocalPlayer.Name
    })
    local embed1 = myMessage.addEmbed(DisplayName.Text, 0x57F287, gen.Text, nil, GetBrainrotUrl(DisplayName.Text))
    embed1.addField("Server Id", game.JobId, false)
    myMessage.sendMessage()
end

local function DiscordNotificationNAME(txtlbl: TextLabel)
    print("[DEBUG] DiscordNotificationNAME called for:", txtlbl.Text)
    local myMessage = webhookUtil.createMessage({
        Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
        username = "Script Logs",
        content = "A good server found by: " .. game.Players.LocalPlayer.Name
    })
    local embed1 = myMessage.addEmbed(txtlbl.Text, 0x57F287, "brainrot found by name", nil, GetBrainrotUrl(txtlbl.Text))
    embed1.addField("Server Id", game.JobId, false)
    myMessage.sendMessage()
end

local Names = {"Chicleteira Bicicleteira", "Los Chicleteiras", "Rang Ring Bus", "Los Burritos", "Secret Lucky Block"}

local function GetAnimalOverhead()
    print("[DEBUG] GetAnimalOverhead scanning...")
    local animalOverheadTable = {}
    for _, SurfaceGui in pairs(workspace:GetDescendants()) do
        if SurfaceGui:IsA("SurfaceGui") and SurfaceGui.Name == "AnimalOverhead" then
            table.insert(animalOverheadTable, SurfaceGui)
        end
    end
    print("[DEBUG] Found", #animalOverheadTable, "AnimalOverhead")
    return animalOverheadTable
end

local function GetMostValuable(strings, minimum)
    print("[DEBUG] GetMostValuable - count:", #strings, "min:", minimum)
    local bestValue = -math.huge
    local bestTextLabel = nil
    local bestString = nil
    for _, txtlbl in ipairs(strings) do
        local str = txtlbl.Text
        print("[DEBUG] Checking string:", str)
        local number, suffix = string.match(str:lower(), "^%s*%$?(%d*%.?%d+)%s*([kmb]?)%s*/?s?$")
        if number then
            local value = tonumber(number)
            if value then
                if suffix == "k" then value = value * 1_000
                elseif suffix == "m" then value = value * 1_000_000
                elseif suffix == "b" then value = value * 1_000_000_000
                end
                print("[DEBUG] Parsed value:", value)
                if value > bestValue then
                    bestValue = value
                    bestTextLabel = txtlbl
                    bestString = str
                end
            end
        else
            print("[DEBUG] Invalid format")
        end
    end
    if bestValue == -math.huge then
        print("[DEBUG] No valid found")
        return false, nil, nil
    end
    local meetsMinimum = bestValue >= minimum
    print("[DEBUG] Best:", bestString, bestValue, "Meets min:", meetsMinimum)
    return meetsMinimum, bestTextLabel, bestString
end

local function CheckNames()
    print("[DEBUG] CheckNames start")
    local nameMatch = nil
    local AnimalOverheadTabel = GetAnimalOverhead()
    for _, overhead in pairs(AnimalOverheadTabel) do
        local DisplayName = overhead:FindFirstChild("DisplayName")
        local Stolen = overhead:FindFirstChild("Stolen")
        if Stolen and Stolen.Text == "FUSING" and Stolen.Visible == true then 
            print("[DEBUG] Skipping FUSING:", DisplayName.Text)
            continue 
        end
        if not DisplayName then continue end
        print("[DEBUG] Checking name:", DisplayName.Text)
        if table.find(Names, DisplayName.Text) then
            nameMatch = DisplayName
            print("[DEBUG] MATCH FOUND:", DisplayName.Text)
            break
        end
    end
    print("[DEBUG] Name check result:", nameMatch and "FOUND" or "NOT FOUND")
    return nameMatch ~= nil, nameMatch
end

local function CheckCurrency(minimum)
    print("[DEBUG] CheckCurrency start - min:", minimum)
    local valuetable = {}
    local textLabelCount = 0
    local AnimalOverheadTabel = GetAnimalOverhead()
    for _, overhead in pairs(AnimalOverheadTabel) do
        local Stolen = overhead:FindFirstChild("Stolen")
        local gen = overhead:FindFirstChild("Generation")
        if Stolen and Stolen.Text == "FUSING" and Stolen.Visible == true then 
            print("[DEBUG] Skipping FUSING")
            continue 
        end
        if not gen then continue end
        textLabelCount = textLabelCount + 1
        table.insert(valuetable, gen)
        print("[DEBUG] Added gen:", gen.Text)
    end
    print("[DEBUG] Total gens:", textLabelCount)
    local meetsMinimum, textlabel, amount = GetMostValuable(valuetable, minimum)
    return meetsMinimum, amount, textlabel
end

-- Your original ServerHop function unchanged (only added some prints inside)
local function ServerHop()
    print("[DEBUG] ServerHop called - starting hop")
    local Tried
    local API, HttpService, TeleportService, CoreGui = nil, game:GetService("HttpService"), game:GetService("TeleportService"), game:GetService("CoreGui");
    local RemoveErrorPrompts = true
    local IterationSpeed = 0.25
    local ExcludefullServers = false
    local SaveTeleportAttempts = false
    local function EncodeToFile(JSONString)
        print("[DEBUG HOP] EncodeToFile")
        local success, JSONData = pcall(function()
            return HttpService:JSONDecode(JSONString)
        end)
        if success and JSONData.data then
            JSONData.gameId = game.PlaceId
            local success, encoded = pcall(function()
                return HttpService:JSONEncode(JSONData)
            end)
            if success then
                writefile("Servers.JSON", encoded)
            else
                error("Failed to encode JSON string.")
                return
            end
        else
            error("Failed to decode JSONData.")
            return
        end
        return JSONData
    end
    local function NextCursor(ep)
        print("[DEBUG HOP] NextCursor")
        return game:HttpGet(API .. "&excludeFullGames=" .. tostring(ExcludefullServers) .. ((ep and "&cursor=" .. ep) or ""))
    end
    local function StartTeleport()
        print("[DEBUG HOP] StartTeleport")
        local JSONData = EncodeToFile(readfile("Servers.JSON"))
        for i = 0, 99 do
            if #JSONData.data <= 1 then
                print("[DEBUG HOP] Few servers left - fetching next page")
                EncodeToFile(NextCursor(JSONData.nextPageCursor))
                TeleportService:Teleport(game.PlaceId, game.Players.LocalPlayer)
            end
            if JSONData.data[i] then
                local JobId = JSONData.data[i].id
                print("[DEBUG HOP] Attempting teleport to:", JobId)
                table.remove(JSONData.data, i)
                local sucess, encoded = pcall(function()
                    return HttpService:JSONEncode(JSONData)
                end)
                writefile("Servers.JSON", encoded)
                if SaveTeleportAttempts then
                    appendfile("Attempts.txt", JobId .. "\n")
                end
                TeleportService:TeleportToPlaceInstance(game.PlaceId, JobId, game.Players.LocalPlayer)
                Tried = true
                task.wait(IterationSpeed)
            end
        end
    end
    local function SetMainPage()
        print("[DEBUG HOP] SetMainPage - fetching initial")
        local MainPage = game:HttpGet(API)
        writefile("Servers.JSON", MainPage)
        StartTeleport()
    end
    API = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"
    if RemoveErrorPrompts then
        print("[DEBUG HOP] Removing error prompts")
        local ep = CoreGui:WaitForChild("RobloxGui"):WaitForChild("Modules"):FindFirstChild("ErrorPrompt")
        if ep then
            ep:Destroy()
        end
        if CoreGui:FindFirstChild("RobloxPromptGui") then
            CoreGui.RobloxPromptGui:Destroy()
        end
    end
    if isfile("Servers.JSON") then
        print("[DEBUG HOP] Servers.JSON exists - loading")
        local success, JSONData = pcall(function()
            return HttpService:JSONDecode(readfile("Servers.JSON"))
        end)
        if success and JSONData then
            if JSONData.gameId ~= game.PlaceId then
                warn("Game mismatch from cache, remaking cache for --> " .. game.PlaceId)
                SetMainPage()
            end
            if JSONData.data and #JSONData.data >= 1 then
                StartTeleport()
            else
                if success and JSONData.nextPageCursor then
                    EncodeToFile(NextCursor(JSONData.nextPageCursor))
                    StartTeleport()
                else
                    SetMainPage()
                end
            end
        else
            SetMainPage()
        end
    else
        SetMainPage()
    end
    if Tried then
        print("[DEBUG HOP] Tried - recursing hop")
        ServerHop()
    end
end

local minimum = 10000000
print("[DEBUG] Starting checks - min currency:", minimum)

local nameFound, matchedName = CheckNames()
local meetsMinimum, highestAmount, currencyTextLabel = CheckCurrency(minimum)

if meetsMinimum then
    print("[DEBUG] Currency condition met - staying!")
    print("Ooooo we got something")
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://8486683243"
    sound.Volume = 1
    sound.Looped = false
    sound.Parent = game.SoundService
    sound:Play()
    DiscordNotificationCURRENCY(currencyTextLabel)
    task.wait(5)
    ServerHop()
elseif nameFound then
    print("[DEBUG] Name condition met - staying!")
    print("yess we found")
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://8486683243"
    sound.Volume = 1
    sound.Looped = false
    sound.Parent = game.SoundService
    sound:Play()
    DiscordNotificationNAME(matchedName)
    task.wait(5)
    ServerHop()
else
    print("[DEBUG] No good server - hopping!")
    print("trying to leave")
    ServerHop()
end
