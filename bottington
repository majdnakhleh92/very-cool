local queue_on_teleport = queue_on_teleport
local StarterGui = game:GetService("StarterGui")
local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
local brainrotImages = loadstring(game:HttpGet("https://pastebin.com/raw/i0AJf9G9"))()
local Service = game:GetService("HttpService")
local hubName = "Garof ServerHopper"
local Testing = false

-- ────────────────────────────────────────────
-- File paths
-- ────────────────────────────────────────────
local SERVER_CLAIM_FILE   = hubName .. "\\server_claims.json"   -- { [jobId] = os.time() }
local BRAINROT_CLAIM_FILE = hubName .. "\\brainrot_claims.json" -- { ["Name|Gen"] = os.time() }
local SERVERS_FILE        = hubName .. "\\Servers.JSON"
local FETCH_LOCK          = hubName .. "\\fetch.lock"
local BRAINROT_EXPIRE     = 300  -- 5 min before same brainrot can be pinged again
local SERVER_EXPIRE       = 600  -- 10 min before a claimed server is considered abandoned

makefolder(hubName)

-- Init files if missing
if not isfile(SERVER_CLAIM_FILE)   then writefile(SERVER_CLAIM_FILE,   Service:JSONEncode({})) end
if not isfile(BRAINROT_CLAIM_FILE) then writefile(BRAINROT_CLAIM_FILE, Service:JSONEncode({})) end

-- ────────────────────────────────────────────
-- Helpers
-- ────────────────────────────────────────────
local function SafeRead(path)
	if not isfile(path) then return {} end
	local ok, data = pcall(function() return Service:JSONDecode(readfile(path)) end)
	if ok and data then return data end
	return {}
end

local function SafeWrite(path, data)
	pcall(function() writefile(path, Service:JSONEncode(data)) end)
end

local function CleanExpired(tbl, expireSeconds)
	local now = os.time()
	for k, t in pairs(tbl) do
		if (now - t) > expireSeconds then tbl[k] = nil end
	end
	return tbl
end

-- ────────────────────────────────────────────
-- Server claiming
-- ────────────────────────────────────────────
local function ClaimCurrentServer()
	local claims = SafeRead(SERVER_CLAIM_FILE)
	claims = CleanExpired(claims, SERVER_EXPIRE)
	claims[game.JobId] = os.time()
	SafeWrite(SERVER_CLAIM_FILE, claims)
end

local function IsServerClaimed(jobId)
	local claims = SafeRead(SERVER_CLAIM_FILE)
	local t = claims[jobId]
	if t == nil then return false end
	return (os.time() - t) < SERVER_EXPIRE
end

-- ────────────────────────────────────────────
-- Brainrot claiming (so 2 bots dont ping the same one)
-- key = "Name|Gen"
-- ────────────────────────────────────────────
local function MakeBrainrotKey(name, gen)
	return tostring(name) .. "|" .. tostring(gen or "")
end

local function IsbrainrotClaimed(name, gen)
	local claims = SafeRead(BRAINROT_CLAIM_FILE)
	local t = claims[MakeBrainrotKey(name, gen)]
	if t == nil then return false end
	return (os.time() - t) < BRAINROT_EXPIRE
end

local function ClaimBrainrot(name, gen)
	local claims = SafeRead(BRAINROT_CLAIM_FILE)
	claims = CleanExpired(claims, BRAINROT_EXPIRE)
	claims[MakeBrainrotKey(name, gen)] = os.time()
	SafeWrite(BRAINROT_CLAIM_FILE, claims)
end

-- ────────────────────────────────────────────
-- Settings
-- ────────────────────────────────────────────
local Settings = {}

function SaveSettings()
	SafeWrite(hubName .. "\\configName.cfg", Settings)
end

function LoadSettings()
	if isfile(hubName .. "\\configName.cfg") then
		local ok, data = pcall(function() return Service:JSONDecode(readfile(hubName .. "\\configName.cfg")) end)
		if ok and data then
			Settings = data
			if not Settings["Server Count"] then Settings["Server Count"] = 0 end
		end
	end
end

LoadSettings()

-- ────────────────────────────────────────────
-- Teleport persistence
-- ────────────────────────────────────────────
if started and not Testing then
	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = function(button)
		if button == "Yes" then
			game["Teleport Service"]:Teleport(game.PlaceId, game.Players.LocalPlayer)
		end
	end
	StarterGui:SetCore("SendNotification", {
		Title = "The script is already running!",
		Text = "Teleport to start?",
		Duration = 5,
		Button1 = "Yes",
		Button2 = "No",
		Callback = bindable
	})
	return
end
pcall(function() getgenv().started = true end)

game.Players.LocalPlayer.OnTeleport:Connect(function(state)
	if state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.InProgress then return end
	queue_on_teleport([[
		repeat task.wait() until game:IsLoaded() and game.Players.LocalPlayer and game.Players.LocalPlayer.Character
		task.wait(2)
		local url = "https://raw.githubusercontent.com/majdnakhleh92/very-cool/refs/heads/main/script"
		local StarterGui = game:GetService("StarterGui")
		local SoundService = game:GetService("SoundService")
		local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
		local func, err = pcall(function() loadstring(game:HttpGet(url))() end)
		if not func then
			print(err)
			StarterGui:SetCore("SendNotification", { Title = "SOMETHING WENT WRONG!!!", Text = "somethingwentwrong", Duration = 5 })
			local sound = Instance.new("Sound")
			sound.SoundId = "rbxassetid://4881487887"
			sound.Volume = 0.5
			sound.Parent = game:GetService("SoundService")
			sound:Play()
			getgenv().started = false
			local msg = ""
			if err == 'http error occured: "HTTP/1.1 429 Too Many Requests"' then msg = "Lower the teleport delay!" end
			local myMessage = webhookUtil.createMessage({
				Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
				username = "Script Logs",
				content = msg
			})
			myMessage.addEmbed("error occured", 0x57F287, err, nil, nil)
			myMessage.sendMessage()
		end
	]])
end)

-- ────────────────────────────────────────────
-- Utility
-- ────────────────────────────────────────────
local function GetPlayerNameFromLabel(textLabel)
	if not textLabel or not textLabel:IsA("TextLabel") or not textLabel.Text then return nil end
	local text = textLabel.Text
	local playerName = string.match(text, "^(.+)'s Base$")
	if playerName then
		for _, PLR in pairs(game.Players:GetPlayers()) do
			if PLR.Name == playerName or PLR.DisplayName == playerName then return PLR end
		end
		return nil
	end
	if string.match(text, "^Empty Base$") then return nil end
	warn("Unexpected base label format: " .. text)
	return nil
end

local function GetBrainrotUrl(name)
	return brainrotImages[name] or nil
end

local function Anonymousify()
	local player = game.Players.LocalPlayer
	for _, plot in pairs(workspace.Plots:GetChildren()) do
		if not plot then continue end
		local PlotSign = plot:FindFirstChild("PlotSign")
		if not PlotSign then continue end
		local SurfaceGui = PlotSign:FindFirstChild("SurfaceGui")
		if not SurfaceGui then continue end
		local Frame = SurfaceGui:FindFirstChild("Frame")
		if not Frame then continue end
		local textlabel = Frame:FindFirstChild("TextLabel")
		if not textlabel then continue end
		if player == GetPlayerNameFromLabel(textlabel) then
			textlabel.Text = "good luck finding me lmao"
		end
	end
end

local function GetAnimalOverhead()
	local t = {}
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("SurfaceGui") and v.Name == "AnimalOverhead" then
			table.insert(t, v)
		end
	end
	return t
end

local blacklist = Settings["Blacklist"] or {"La Grande Combinasion","Los Nooo My Hotspotsitos","Bunito Bunito Spinito","Horegini Boom","Lucky Block","Giftini Spyderini","Santa Hotspot","Naughty Naughty","Los Cucarachas","La Cucaracha","Pot Hotspot","Los 25","Ho Ho Ho Sahur","To to to Sahur","Chimnino","Graipuss Medussi","Rocco Disco","Triplito Tralaleritos","La Vacca Prese Presente","Los Tralaleritos","Guerriro Digitale","Noo my Present","Las Tralaleritas","Los Tortus","Job Job Job Sahur","Los Burritos","Los Jobcitos","Burrito Bandito","Quesadilla Crocodila","Los Quesadillas","Tung Tung Tung Sahur","Cuadramat and Pakrahmatmamat","List List List Sahur","Chicleteirina Bicicleteirina"}
local Priority = Settings["Whitelist"] or {"Nooo my Hotspot","Raccooni Jandelini","Quesadillo Vampiro"}

-- ────────────────────────────────────────────
-- Detection
-- ────────────────────────────────────────────
local function GetMostValuable(strings, minimum)
	local bestValue = -math.huge
	local bestTextLabel = nil
	local minimumMetTextLabels = {}

	for _, txtlbl in ipairs(strings) do
		local str = txtlbl.Text
		local number, suffix = string.match(str:lower(), "^%s*%$?(%d*%.?%d+)%s*([kmb]?)%s*/?s?$")
		if number then
			local value = tonumber(number)
			if value then
				if suffix == "k" then value = value * 1_000
				elseif suffix == "m" then value = value * 1_000_000
				elseif suffix == "b" then value = value * 1_000_000_000
				end
				if value > bestValue then
					bestValue = value
					bestTextLabel = txtlbl
				end
				if value >= minimum then
					table.insert(minimumMetTextLabels, {label = txtlbl, value = value})
				end
			end
		end
	end

	if bestValue == -math.huge then return false, nil, nil, {} end

	table.sort(minimumMetTextLabels, function(a, b) return a.value > b.value end)

	local temp = {}
	for _, entry in ipairs(minimumMetTextLabels) do
		local overhead = entry.label.Parent
		local dpName = overhead:FindFirstChild("DisplayName")
		if dpName then table.insert(temp, dpName.Text .. " (" .. entry.label.Text .. ")") end
	end

	return bestValue >= minimum, bestTextLabel, nil, temp
end

local function CheckCurrency(minimum)
	local valuetable = {}
	for _, overhead in pairs(GetAnimalOverhead()) do
		local Stolen = overhead:FindFirstChild("Stolen")
		local displayName = overhead:FindFirstChild("DisplayName")
		local gen = overhead:FindFirstChild("Generation")
		if Stolen and (Stolen.Text == "FUSING" or Stolen.Text == "IN DUEL") and Stolen.Visible then continue end
		if not gen then continue end
		if displayName and table.find(blacklist, displayName.Text) then continue end
		table.insert(valuetable, gen)
	end
	return GetMostValuable(valuetable, minimum)
end

local function CheckNames()
	local nameMatches = {}
	for _, overhead in pairs(GetAnimalOverhead()) do
		local DisplayName = overhead:FindFirstChild("DisplayName")
		local Stolen = overhead:FindFirstChild("Stolen")
		if Stolen and Stolen.Text == "FUSING" and Stolen.Visible then continue end
		if not DisplayName then continue end
		if table.find(Priority, DisplayName.Text) then
			table.insert(nameMatches, DisplayName)
		elseif DisplayName.Text == "Lucky Block" then
			if overhead:FindFirstChild("Rarity") and overhead.Rarity.Text == "Secret" then
				table.insert(nameMatches, DisplayName)
			end
		end
	end
	if #nameMatches > 0 then return true, nameMatches[1] end
	return false, nil
end

local function CheckMutations()
	local mutation = Settings["MutationTarget"] or ""
	local Brainrots = Settings["TargetBrainrots"] or {}
	if mutation == "" and #Brainrots == 0 then return false, nil, nil end
	for _, overhead in pairs(GetAnimalOverhead()) do
		local mutationLabel = overhead:FindFirstChild("Mutation")
		local Stolen = overhead:FindFirstChild("Stolen")
		local DisplayName = overhead:FindFirstChild("DisplayName")
		if not DisplayName then continue end
		if Stolen and Stolen.Text == "FUSING" and Stolen.Visible then continue end
		if not mutationLabel or mutationLabel.Visible == false then continue end
		if mutationLabel.Text == mutation and table.find(Brainrots, DisplayName.Text) then
			return true, mutationLabel.Text, DisplayName.Text
		end
	end
	return false, nil, nil
end

-- ────────────────────────────────────────────
-- Discord notifications (return true if ping was sent)
-- ────────────────────────────────────────────
local WEBHOOK = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh"

local function DiscordNotificationCURRENCY(txtlbl, temp)
	local ovrhead = txtlbl.Parent
	local anonymous = Settings["anonymity"] == true and "anonymous" or game.Players.LocalPlayer.Name
	local bestDisplayName = ovrhead:FindFirstChild("DisplayName")
	local bestgen = ovrhead:FindFirstChild("Generation")
	if not bestDisplayName or not bestgen then return false end

	if IsbrainrotClaimed(bestDisplayName.Text, bestgen.Text) then
		print("Already claimed by another bot: " .. bestDisplayName.Text .. " " .. bestgen.Text)
		return false
	end
	ClaimBrainrot(bestDisplayName.Text, bestgen.Text)

	local description = "**⚠︎ Other Brainrots**\n```" .. table.concat(temp, "\n") .. "```"
	local myMessage = webhookUtil.createMessage({ Url = WEBHOOK, username = "Script Logs", content = "A good server found by: " .. anonymous })
	local embed1 = myMessage.addEmbed(bestDisplayName.Text .. " " .. bestgen.Text, Settings["embedColor"] or 0x57F287, description, nil, GetBrainrotUrl(bestDisplayName.Text))
	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Checked", Settings["Server Count"], false)
	end
	myMessage.sendMessage()
	return true
end

local function DiscordNotificationNAME(txtlbl)
	local anonymous = Settings["anonymity"] == true and "anonymous" or game.Players.LocalPlayer.Name
	local overhead = txtlbl.Parent
	local genLabel = overhead and overhead:FindFirstChild("Generation")
	local gen = genLabel and genLabel.Text or ""

	if IsbrainrotClaimed(txtlbl.Text, gen) then
		print("Already claimed by another bot: " .. txtlbl.Text)
		return false
	end
	ClaimBrainrot(txtlbl.Text, gen)

	local myMessage = webhookUtil.createMessage({ Url = WEBHOOK, username = "Script Logs", content = "A good server found by: " .. anonymous })
	local embed1 = myMessage.addEmbed(txtlbl.Text, Settings["embedColor"] or 0x57F287, "brainrot found by name", nil, GetBrainrotUrl(txtlbl.Text))
	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Checked", Settings["Server Count"], false)
	end
	myMessage.sendMessage()
	return true
end

local function DiscordNotificationMUTATION(Mutation, Brainrot)
	local anonymous = Settings["anonymity"] == true and "anonymous" or game.Players.LocalPlayer.Name

	if IsbrainrotClaimed(Brainrot, Mutation) then
		print("Already claimed by another bot: " .. Brainrot .. " " .. Mutation)
		return false
	end
	ClaimBrainrot(Brainrot, Mutation)

	local myMessage = webhookUtil.createMessage({ Url = WEBHOOK, username = "Script Logs", content = "A good server found by: " .. anonymous })
	local embed1 = myMessage.addEmbed(Brainrot .. " Mutated With: " .. Mutation, Settings["embedColor"] or 0x57F287, "brainrot found by mutation", nil, GetBrainrotUrl(Brainrot))
	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Checked", Settings["Server Count"], false)
	end
	myMessage.sendMessage()
	return true
end

-- ────────────────────────────────────────────
-- Serverhop — find an unclaimed server and go there
-- ────────────────────────────────────────────
local function Serverhop()
	local HttpService    = game:GetService("HttpService")
	local TeleportService = game:GetService("TeleportService")
	local CoreGui        = game:GetService("CoreGui")
	local IterationSpeed = Settings["ServerhopSpeed"] or 0.30
	local ExcludefullServers = Settings["ExcludefullServers"] or false
	local API = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"

	if Testing then return end

	if Settings["RemoveErrorPrompts"] ~= false then
		local RG = CoreGui:FindFirstChild("RobloxGui")
		local M = RG and RG:FindFirstChild("Modules")
		local EP = M and M:FindFirstChild("ErrorPrompt")
		if EP then EP:Destroy() end
		local RPG = CoreGui:FindFirstChild("RobloxPromptGui")
		if RPG then RPG:Destroy() end
	end

	local function FetchPage(cursor)
		if isfile(FETCH_LOCK) then
			local waited = 0
			repeat task.wait(0.1) waited += 0.1 until not isfile(FETCH_LOCK) or waited > 5
		end
		writefile(FETCH_LOCK, "1")
		local ok, result = pcall(function()
			return game:HttpGet(API .. "&excludeFullGames=" .. tostring(ExcludefullServers) .. (cursor and ("&cursor=" .. cursor) or ""))
		end)
		pcall(function() delfile(FETCH_LOCK) end)
		return ok and result or nil
	end

	local function LoadOrFetchServers()
		if isfile(SERVERS_FILE) then
			local ok, data = pcall(function() return HttpService:JSONDecode(readfile(SERVERS_FILE)) end)
			if ok and data and data.gameId == game.PlaceId and data.data and #data.data > 0 then
				return data
			end
		end
		local raw = FetchPage(nil)
		if not raw then return nil end
		local ok, data = pcall(function() return HttpService:JSONDecode(raw) end)
		if ok and data then
			data.gameId = game.PlaceId
			SafeWrite(SERVERS_FILE, data)
			return data
		end
		return nil
	end

	local JSONData = LoadOrFetchServers()

	while true do
		-- Always re-read from disk so all bots see the latest state
		if isfile(SERVERS_FILE) then
			local ok, fresh = pcall(function() return HttpService:JSONDecode(readfile(SERVERS_FILE)) end)
			if ok and fresh and fresh.gameId == game.PlaceId then
				JSONData = fresh
			end
		end

		if not JSONData or not JSONData.data or #JSONData.data == 0 then
			local cursor = JSONData and JSONData.nextPageCursor or nil
			local raw = FetchPage(cursor)
			if raw then
				local ok, data = pcall(function() return HttpService:JSONDecode(raw) end)
				if ok and data then
					data.gameId = game.PlaceId
					SafeWrite(SERVERS_FILE, data)
					JSONData = data
				end
			end
			task.wait(0.5)
			continue
		end

		-- Find first unclaimed server
		local picked = nil
		for i, server in ipairs(JSONData.data) do
			if not IsServerClaimed(server.id) then
				picked = server.id
				table.remove(JSONData.data, i)
				JSONData.gameId = game.PlaceId
				SafeWrite(SERVERS_FILE, JSONData)
				break
			end
		end

		if picked then
			-- Stamp as claimed before teleport so other bots skip it immediately
			local claims = SafeRead(SERVER_CLAIM_FILE)
			claims = CleanExpired(claims, SERVER_EXPIRE)
			claims[picked] = os.time()
			SafeWrite(SERVER_CLAIM_FILE, claims)

			print("Teleporting to unclaimed server: " .. picked)
			TeleportService:TeleportToPlaceInstance(game.PlaceId, picked, game.Players.LocalPlayer)
			task.wait(IterationSpeed)
			return
		else
			-- All servers on current page claimed, force a fresh page fetch
			print("All servers on page claimed, fetching next page...")
			JSONData.data = {}
			task.wait(0.1)
		end
	end
end

-- ────────────────────────────────────────────
-- Main — claim this server then monitor it forever
-- ────────────────────────────────────────────
local minimum = tonumber(Settings["MoneyPerSecond"]) or 10_000_000

-- If another bot already claimed this server, move on
if IsServerClaimed(game.JobId) then
	print("Server already claimed by another bot — finding a new one...")
	Serverhop()
	return
end

-- Claim it for ourselves
ClaimCurrentServer()
Anonymousify()
print("Bot settled in server: " .. game.JobId .. " — monitoring...")

-- Keep the claim alive every 30s so it doesn't expire
task.spawn(function()
	while true do
		task.wait(30)
		ClaimCurrentServer()
	end
end)

local SCAN_INTERVAL = Settings["ScanInterval"] or 3

local function PlaySound()
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService
	sound:Play()
end

-- Monitor loop — stays in this server permanently
while true do
	task.wait(SCAN_INTERVAL)

	local meetsMinimum, _, currencyTextLabel, temp = CheckCurrency(minimum)
	local nameFound, matchedName = CheckNames()
	local mutatedBrainrotFound, mutation, brainrot = CheckMutations()

	if meetsMinimum and currencyTextLabel then
		if DiscordNotificationCURRENCY(currencyTextLabel, temp) then
			PlaySound()
			Settings["Server Count"] += 1
			SaveSettings()
		end

	elseif nameFound and matchedName then
		if DiscordNotificationNAME(matchedName) then
			PlaySound()
			Settings["Server Count"] += 1
			SaveSettings()
		end

	elseif mutatedBrainrotFound then
		if DiscordNotificationMUTATION(mutation, brainrot) then
			PlaySound()
			Settings["Server Count"] += 1
			SaveSettings()
		end
	end
end
