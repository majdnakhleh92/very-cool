local queue_on_teleport = queue_on_teleport
local StarterGui = game:GetService("StarterGui")
local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
local brainrotImages = loadstring(game:HttpGet("https://pastebin.com/raw/i0AJf9G9"))()
local Service = game:GetService("HttpService")
local hubName = "Garof ServerHopper" -- idk it ain a hub lmao
local Testing = false

if started and not Testing then
	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = function(button)
		if button == "Yes" then
			game["Teleport Service"]:Teleport(game.PlaceId, game.Players.LocalPlayer)
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "The script is already running!",
		Text = "Teleport to start?",
		Duration = 5,
		Button1 = "Yes",
		Button2 = "No",
		Callback = bindable
	})
	return 
end
pcall(function() getgenv().started = true end)

game.Players.LocalPlayer.OnTeleport:Connect(function(state)
	if state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.InProgress then return end

	queue_on_teleport([[
		print(1) -- rlly hope this doesnt break bro

		repeat
			task.wait()
		until game:IsLoaded() and game.Players.LocalPlayer and game.Players.LocalPlayer.Character

		print(2)

		task.wait(2)

		print(3)

		local url = "https://raw.githubusercontent.com/majdnakhleh92/very-cool/refs/heads/main/script"
		local StarterGui = game:GetService("StarterGui")
		local SoundService = game:GetService("SoundService")
		local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()

		local func, err = pcall(function()
			loadstring(game:HttpGet(url))()
		end)

		if not func then
			print(err)
			StarterGui:SetCore("SendNotification", {
				Title = "SOMETHING WENT WRONG!!!",
				Text = "somethingwentwrong",
				Duration = 5
			})

			local sound = Instance.new("Sound")
			sound.SoundId = "rbxassetid://4881487887"
			sound.Volume = 0.5
			sound.Looped = false
			sound.Parent = SoundService
			sound:Play()
			getgenv().started = false
			local msg = ""
			if err == 'http error occured: "HTTP/1.1 429 Too Many Requests"' then
				msg = "Lower the teleport delay!"
			end
			
			local myMessage = webhookUtil.createMessage({
				Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
				username = "Script Logs",
				content = msg 
			})

			local embed1 = myMessage.addEmbed(
				"error occured",
				0x57F287,
				err,
				nil,
				nil
			)

			myMessage.sendMessage()
		end
    ]])
end)

local Settings = {}

makefolder(hubName)

function SaveSettings()
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

function LoadSettings()
	if isfile(hubName .. "\\configName.cfg") then
		Settings = Service:JSONDecode(readfile(hubName .. "\\configName.cfg"))
		if not Settings["Server Count"] then Settings["Server Count"] = 0 end
	end
end

LoadSettings()

function ResetSettings()
	Settings["Server Count"] = 0
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

local function GetPlayerNameFromLabel(textLabel)
	if not textLabel or not textLabel:IsA("TextLabel") or not textLabel.Text then
		return nil
	end

	local text = textLabel.Text
	local playerName = string.match(text, "^(.+)'s Base$")

	if playerName then
		for _, PLR in pairs(game.Players:GetPlayers()) do
			if PLR.Name == playerName or PLR.DisplayName == playerName then
				return PLR
			end
		end
		return nil
	else

		if string.match(text, "^Empty Base$") then
			return nil
		else

			warn("Unexpected base label format: " .. text)
			return nil
		end
	end
end

local function GetBrainrotUrl(name)
	local brainrotImage = brainrotImages[name]
	if brainrotImage then
		return brainrotImage
	end
	return nil
end

local function Anonymousify()
	local player = game.Players.LocalPlayer	
	for _, plot in pairs(workspace.Plots:GetChildren()) do
		if not plot then continue end

		local PlotSign = plot:FindFirstChild("PlotSign")
		if not PlotSign then continue end
		local SurfaceGui = PlotSign:FindFirstChild("SurfaceGui")
		if not SurfaceGui then continue end
		local Frame = SurfaceGui:FindFirstChild("Frame")
		if not Frame then continue end
		local textlabel = Frame:FindFirstChild("TextLabel")
		if not textlabel then continue end

		local playerFromSign = GetPlayerNameFromLabel(textlabel)
		if player == playerFromSign then
			textlabel.Text = "good luck finding me lmao"
		end
	end
end

local function DiscordNotificationCURRENCY(txtlbl, temp)

	local ovrhead = txtlbl.Parent
	local anonymous = game.Players.LocalPlayer.Name
	local bestDisplayName = ovrhead:FindFirstChild("DisplayName")
	local bestgen = ovrhead:FindFirstChild("Generation")

	local description = "**⚠︎ Other Brainrots**\n```" .. table.concat(temp, "\n") .. "```"
	if Settings["anonymity"] == true then anonymous = "anonymous" end
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
		username = "Script Logs",
		content = "A good server found by: " .. anonymous
	})

	local embed1 = myMessage.addEmbed(
		bestDisplayName.Text .. " " .. bestgen.Text,
		Settings["embedColor"] or 0x57F287,
		description,
		nil,
		GetBrainrotUrl(bestDisplayName.Text)
	)

	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Hopped", Settings["Server Count"], false)
	end

	myMessage.sendMessage()
	ResetSettings()
	return
end

local function DiscordNotificationNAME(txtlbl: TextLabel)

	local anonymous = game.Players.LocalPlayer.Name

	if Settings["anonymity"] == true then anonymous = "anonymous" end
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
		username = "Script Logs",
		content = "A good server found by: " .. anonymous
	})

	local embed1 = myMessage.addEmbed(
		txtlbl.Text,
		Settings["embedColor"] or 0x57F287,
		"brainrot found by name",
		nil,
		GetBrainrotUrl(txtlbl.Text)
	)

	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Hopped", Settings["Server Count"], false)
	end

	myMessage.sendMessage()
	ResetSettings()
	return
end

local function DiscordNotificationMUTATION(Mutation, Brainrot)
	local anonymous = game.Players.LocalPlayer.Name

	if Settings["anonymity"] == true then anonymous = "anonymous" end
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
		username = "Script Logs",
		content = "A good server found by: " .. anonymous
	})

	local embed1 = myMessage.addEmbed(
		Brainrot .. " Mutated With: " .. Mutation,
		Settings["embedColor"] or 0x57F287,
		"brainrot found by mutation",
		nil,
		GetBrainrotUrl(Brainrot.Text)
	)

	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Hopped", Settings["Server Count"], false)
	end

	myMessage.sendMessage()
	ResetSettings()
	return
end

local blacklist = Settings["Blacklist"] or {"La Grande Combinasion", "Los Nooo My Hotspotsitos", "Bunito Bunito Spinito", "Horegini Boom", "Lucky Block", "Giftini Spyderini", "Santa Hotspot", "Naughty Naughty", "Los Cucarachas", "La Cucaracha", "Pot Hotspot", "Los 25", "Ho Ho Ho Sahur", "To to to Sahur", "Chimnino", "Graipuss Medussi", "Rocco Disco", "Triplito Tralaleritos", "La Vacca Prese Presente", "Los Tralaleritos", "Guerriro Digitale", "Noo my Present", "Las Tralaleritas", "Los Tortus", "Job Job Job Sahur", "Los Burritos", "Los Jobcitos", "Burrito Bandito", "Quesadilla Crocodila", "Los Quesadillas", "Tung Tung Tung Sahur", "Cuadramat and Pakrahmatmamat", "List List List Sahur", "Chicleteirina Bicicleteirina"}
local Priority = Settings["Whitelist"] or {"Nooo my Hotspot", "Raccooni Jandelini", "Quesadillo Vampiro"}

local function GetAnimalOverhead()
	local animalOverheadTable = {}

	for _, SurfaceGui in pairs(workspace:GetDescendants()) do
		if SurfaceGui:IsA("SurfaceGui") and SurfaceGui.Name == "AnimalOverhead" then
			table.insert(animalOverheadTable, SurfaceGui)
		end
	end

	return animalOverheadTable
end

local function GetMostValuable(strings, minimum)
	local bestValue = -math.huge
	local bestTextLabel = nil
	local bestString = nil
	local minimumMetTextLabels = {}

	for _, txtlbl in ipairs(strings) do
		local str = txtlbl.Text
		local number, suffix = string.match(str:lower(), "^%s*%$?(%d*%.?%d+)%s*([kmb]?)%s*/?s?$")
		if number then
			local value = tonumber(number)
			if value then
				if suffix == "k" then
					value = value * 1_000
				elseif suffix == "m" then
					value = value * 1_000_000
				elseif suffix == "b" then
					value = value * 1_000_000_000
				end
				if value > bestValue then
					bestValue = value
					bestTextLabel = txtlbl
					bestString = str
					print("Valid currency string: " .. str .. " -> Value: " .. value)
				end
				if value >= minimum then
					table.insert(minimumMetTextLabels, {label = txtlbl, value = value})
				end
			end
		else
			print("Skipped non-currency string: " .. str)
		end
	end

	if bestValue == -math.huge then
		print("No valid currency strings found")
		return false, nil, nil, {}
	end

	table.sort(minimumMetTextLabels, function(a, b)
		return a.value > b.value
	end)

	local temp = {}
	for _, entry in ipairs(minimumMetTextLabels) do
		local generation = entry.label.Text
		local overhead = entry.label.Parent
		local dpName = overhead.DisplayName
		table.insert(temp, dpName.Text .. " (" .. generation .. ")")
	end

	local meetsMinimum = bestValue >= minimum
	print(string.format("Highest value: %d, Minimum: %d, Meets minimum: %s", bestValue, minimum, tostring(meetsMinimum)))

	return meetsMinimum, bestTextLabel, bestString, temp
end

local function CheckMutations()
	local mutation = Settings["MutationTarget"] or ""
	local Brainrots = Settings["TargetBrainrots"] or {}
	local MutatedBrainrotFound, Mutation, brainrot

	if mutation == "" and #Brainrots == 0 then return end

	local AnimalOverheadTable = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTable) do
		local mutationLabel = overhead:FindFirstChild("Mutation")
		local Stolen = overhead:FindFirstChild("Stolen")
		local DisplayName = overhead:FindFirstChild("DisplayName")

		if not DisplayName then continue end
		if Stolen and Stolen.Text == "FUSING" and Stolen.Visible == true then continue end
		if mutationLabel and mutationLabel.Visible == false then continue end

		if mutationLabel.Text == "Diamond" and DisplayName.Text == "Trippi Troppi" then
			print("its freaky")
		end

		if mutationLabel.Text == mutation and table.find(Brainrots, DisplayName.Text) then
			MutatedBrainrotFound = true
			Mutation = mutationLabel.Text
			brainrot = DisplayName.Text
			print("working")
			break
		end
	end

	return MutatedBrainrotFound, Mutation, brainrot
end

local function CheckNames() 
	local nameMatches = {}

	local AnimalOverheadTabel = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTabel) do
		local DisplayName = overhead:FindFirstChild("DisplayName")
		local Stolen = overhead:FindFirstChild("Stolen")

		if Stolen and Stolen.Text == "FUSING" and Stolen.Visible == true then continue end
		if not DisplayName then continue end

		if table.find(Priority, DisplayName.Text) then
			table.insert(nameMatches, DisplayName)

		elseif DisplayName.Text == "Lucky Block" then
			if overhead:FindFirstChild("Rarity") and overhead.Rarity.Text == "Secret" then 
				table.insert(nameMatches, DisplayName)
			end
		end
	end

	if #nameMatches > 0 then
		return true, nameMatches[1]
	end

	return false, nil
end

local function CheckCurrency(minimum)
	local valuetable = {}
	local AnimalOverheadTabel = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTabel) do
		local Stolen = overhead:FindFirstChild("Stolen")
		local displayName = overhead:FindFirstChild("DisplayName")
		local gen = overhead:FindFirstChild("Generation")

		if Stolen and (Stolen.Text == "FUSING" or Stolen.Text == "IN DUEL") and Stolen.Visible == true then 
			continue 
		end

		if not gen then continue end

		if displayName and table.find(blacklist, displayName.Text) then 
			print("Blacklisted: " .. displayName.Text)
			continue 
		end

		table.insert(valuetable, gen)
	end

	local meetsMinimum, textlabel, amount, minimumMetTextLabels = GetMostValuable(valuetable, minimum)
	return meetsMinimum, amount, textlabel, minimumMetTextLabels
end

local function Serverhop()
	local Tried
	local HttpService, TeleportService, CoreGui = game:GetService("HttpService"), game:GetService("TeleportService"), game:GetService("CoreGui");
	local RemoveErrorPrompts = Settings["RemoveErrorPrompts"] or true --prevents error messages from popping up.
	local IterationSpeed = Settings["ServerhopSpeed"] or 0.30 --speed in which next server is picked for teleport (the higher it is the slower the teleports but more likely to work).
	local ExcludefullServers = Settings["ExcludefullServers"] or false --slightly beneficial if the game is high ccu or mid ccu, if not, set to false.
	local SaveTeleportAttempts = Settings["SaveTeleportAttempts"] or false --saves every teleports that are attempted in jobid to "Attempts.txt" file
	local API = Settings["API"] or "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"

	if Testing then return end
	local function EncodeToFile(JSONString)
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(JSONString)
		end)
		if success and JSONData.data then
			JSONData.gameId = game.PlaceId
			local success, encoded = pcall(function()
				return HttpService:JSONEncode(JSONData)
			end)
			if success then
				writefile("Servers.JSON", encoded)
			else
				warn("Failed to encode JSON string.")
				return nil
			end
		else
			warn("Failed to decode JSONData.")
			return nil
		end
		return JSONData
	end

	local function NextCursor(ep)
		return game:HttpGet(API .. "&excludeFullGames=" .. tostring(ExcludefullServers) .. ((ep and "&cursor=" .. ep) or ""))
	end

	local function StartTeleport()
		Tried = true
		local JSONData = EncodeToFile(readfile("Servers.JSON"))
		if not JSONData then
			writefile("Servers.JSON", game:HttpGet(API))
			StartTeleport()
		end
		for i = 0, 99 do
			if #JSONData.data <= 1 then
				EncodeToFile(NextCursor(JSONData.nextPageCursor))
				TeleportService:Teleport(game.PlaceId, game.Players.LocalPlayer)
			end
			if JSONData.data[i] then
				local JobId = JSONData.data[i].id
				table.remove(JSONData.data, i)
				local sucess, encoded = pcall(function()
					return HttpService:JSONEncode(JSONData)
				end)
				writefile("Servers.JSON", encoded)
				if SaveTeleportAttempts then
					appendfile("Attempts.txt", JobId .. "\n")
				end
				TeleportService:TeleportToPlaceInstance(game.PlaceId, JobId, game.Players.LocalPlayer)
				task.wait(IterationSpeed)
			end
		end
	end

	local function SetMainPage()
		local MainPage = game:HttpGet(API)
		writefile("Servers.JSON", MainPage)
		StartTeleport()
	end

	if RemoveErrorPrompts then 
		local RG = CoreGui:FindFirstChild("RobloxGui")
		local M = RG and RG:FindFirstChild("Modules")
		local EP = M and M:FindFirstChild("ErrorPrompt")

		if EP then
			EP:Destroy()
		end

		local RPG = CoreGui:FindFirstChild("RobloxPromptGui")
		if RPG then
			RPG:Destroy()
		end
	end

	if isfile("Servers.JSON") then
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(readfile("Servers.JSON"))
		end)
		if success and JSONData then
			if JSONData.gameId ~= game.PlaceId then
				warn("Game mismatch from cache, remaking cache for --> " .. game.PlaceId)
				SetMainPage()
			end
			if JSONData.data and #JSONData.data >= 1 then
				StartTeleport()
			else
				if success and JSONData.nextPageCursor then
					EncodeToFile(NextCursor(JSONData.nextPageCursor))
					StartTeleport()
				else
					SetMainPage()
				end
			end
		else
			SetMainPage()
		end
	else
		SetMainPage()
	end

	if Tried then
		print("yaaaaaaaaaaaaaaaaaaaaa")
		Serverhop()
	end
end

local minimum = tonumber(Settings["MoneyPerSecond"]) or 10_000_000
local nameFound, matchedName = CheckNames()
local meetsMinimum, highestAmount, currencyTextLabel, temp = CheckCurrency(minimum)
local mutatedBrainrotFound, mutation, brainrot = CheckMutations()

local hasMatch = meetsMinimum or nameFound
local mainScript = Settings["HubtoLoad"] or "https://raw.githubusercontent.com/ily123950/Vulkan/refs/heads/main/Tr"

if meetsMinimum then
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService 
	sound:Play()

	Anonymousify()
	task.spawn(function()
		loadstring(game:HttpGet(mainScript))()
	end)

	DiscordNotificationCURRENCY(currencyTextLabel, temp)

elseif nameFound then
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService 
	sound:Play()

	Anonymousify()
	task.spawn(function()
		if Testing then return end
		loadstring(game:HttpGet("https://api.luarmor.net/files/v4/loaders/9773df454c0daee602fa4d28960b24b2.lua"))()
		loadstring(game:HttpGet(mainScript))()
	end)

	DiscordNotificationNAME(matchedName)

elseif mutatedBrainrotFound then
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService 
	sound:Play()

	Anonymousify()
	task.spawn(function()
		if Testing then return end
		loadstring(game:HttpGet("https://api.luarmor.net/files/v4/loaders/9773df454c0daee602fa4d28960b24b2.lua"))()
		loadstring(game:HttpGet(mainScript))()
	end)

	DiscordNotificationMUTATION(mutation, brainrot)
else
	Settings["Server Count"] += 1
	SaveSettings()
	Serverhop()
end
