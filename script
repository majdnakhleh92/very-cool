local queue_on_teleport = queue_on_teleport
local StarterGui = game:GetService("StarterGui")
local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()
local brainrotImages = loadstring(game:HttpGet("https://pastebin.com/raw/i0AJf9G9"))()
local Service = game:GetService("HttpService")
local hubName = "Garof ServerHopper" -- idk it ain a hub lmao

if started then
	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = function(button)
		if button == "Yes" then
			game["Teleport Service"]:Teleport(game.PlaceId, game.Players.LocalPlayer)
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "The script is already running!",
		Text = "Teleport to start?",
		Duration = 5,
		Button1 = "Yes",
		Button2 = "No",
		Callback = bindable
	})
	return 
end
pcall(function() getgenv().started = true end)

game.Players.LocalPlayer.OnTeleport:Connect(function(state)
	if state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.InProgress then return end

	queue_on_teleport([[
		print(1) -- rlly hope this doesnt break bro

		repeat
			task.wait()
		until game:IsLoaded() and game.Players.LocalPlayer and game.Players.LocalPlayer.Character

		print(2)

		task.wait(2)

		print(3)

		local url = "https://raw.githubusercontent.com/majdnakhleh92/very-cool/refs/heads/main/script"
		local StarterGui = game:GetService("StarterGui")
		local SoundService = game:GetService("SoundService")
		local webhookUtil = loadstring(game:HttpGet("https://pastebin.com/raw/fpkbJgyq"))()

		local func, err = pcall(function()
			loadstring(game:HttpGet(url))()
		end)

		if not func then
			print(err)
			StarterGui:SetCore("SendNotification", {
				Title = "SOMETHING WENT WRONG!!!",
				Text = "somethingwentwrong",
				Duration = 5
			})

			local sound = Instance.new("Sound")
			sound.SoundId = "rbxassetid://4881487887"
			sound.Volume = 0.5
			sound.Looped = false
			sound.Parent = SoundService
			sound:Play()
			getgenv().started = false
			local msg = ""
			if err == 'http error occured: "HTTP/1.1 429 Too Many Requests"' then
				msg = "Lower the teleport delay!"
			end
			
			local myMessage = webhookUtil.createMessage({
				Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
				username = "Script Logs",
				content = msg 
			})

			local embed1 = myMessage.addEmbed(
				"error occured",
				0x57F287,
				err,
				nil,
				nil
			)

			myMessage.sendMessage()
		end
    ]])
end)

local Settings = {}

makefolder(hubName)

function SaveSettings()
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

function LoadSettings()
	if isfile(hubName .. "\\configName.cfg") then
		if not Settings["Server Count"] then Settings["Server Count"] = 0 end
		Settings = Service:JSONDecode(readfile(hubName .. "\\configName.cfg"))
	end
end

LoadSettings()

function ResetSettings()
	Settings["Server Count"] = 0
	local JSON = Service:JSONEncode(Settings)
	writefile(hubName .. "\\configName.cfg", JSON)
end

local function GetPlayerNameFromLabel(textLabel)
	if not textLabel or not textLabel:IsA("TextLabel") or not textLabel.Text then
		return nil
	end

	local text = textLabel.Text
	local playerName = string.match(text, "^(.+)'s Base$")

	if playerName then
		for _, PLR in pairs(game.Players:GetPlayers()) do
			if PLR.Name == playerName or PLR.DisplayName == playerName then
				return PLR
			end
		end
		return nil
	else

		if string.match(text, "^Empty Base$") then
			return nil
		else

			warn("Unexpected base label format: " .. text)
			return nil
		end
	end
end

local function GetBrainrotUrl(name)
	local brainrotImage = brainrotImages[name]
	if brainrotImage then
		return brainrotImage
	end
	return nil
end

local function Anonymousify()
	local player = game.Players.LocalPlayer	

	for _, plot in pairs(workspace.Plots:GetChildren()) do
		if not plot then return end

		local textlabel = plot:FindFirstChild("PlotSign"):FindFirstChild("SurfaceGui"):FindFirstChild("Frame"):FindFirstChild("TextLabel")
		if not textlabel then return end

		local playerFromSign = GetPlayerNameFromLabel(textlabel)
		if player == playerFromSign then
			textlabel.Text = "good luck finding me lmao"
		end
	end
end

local function DiscordNotificationCURRENCY(txtlbl, temp)

	local ovrhead = txtlbl.Parent
	local anonymous = game.Players.LocalPlayer.Name
	local bestDisplayName = ovrhead:FindFirstChild("DisplayName")
	local bestgen = ovrhead:FindFirstChild("Generation")

	local description = "**⚠︎ Other Brainrots**\n```" .. table.concat(temp, "\n") .. "```"
	if Settings["anonymity"] == true then anonymous = "anonymous" end
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
		username = "Script Logs",
		content = "A good server found by: " .. anonymous
	})

	local embed1 = myMessage.addEmbed(
		bestDisplayName.Text .. " " .. bestgen.Text,
		Settings["embedColor"] or 0x57F287,
		description,
		nil,
		GetBrainrotUrl(bestDisplayName.Text)
	)

	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Hopped", Settings["Server Count"], false)
	end

	myMessage.sendMessage()
	ResetSettings()
	return
end

local function DiscordNotificationNAME(txtlbl: TextLabel)

	local anonymous = game.Players.LocalPlayer.Name

	if Settings["anonymity"] == true then anonymous = "anonymous" end
	local myMessage = webhookUtil.createMessage({
		Url = "https://discord.com/api/webhooks/1317498619770703893/jyiYAeI_GvB1Nw4vcbZNmxyXaReXg2vRiKDxy0txviujU3o_71ec5FAsyxDOEgBGkXoh",
		username = "Script Logs",
		content = "A good server found by: " .. anonymous
	})

	local embed1 = myMessage.addEmbed(
		txtlbl.Text,
		Settings["embedColor"] or 0x57F287,
		"brainrot found by name",
		nil,
		GetBrainrotUrl(txtlbl.Text)
	)

	if anonymous ~= "anonymous" then
		embed1.addField("Server Id", game.JobId, false)
		embed1.addField("Servers Hopped", Settings["Server Count"], false)
	end

	myMessage.sendMessage()
	ResetSettings()
	return
end

local blacklist = Settings["Blacklist"] or {"La Grande Combinasion", "Los Nooo My Hotspotsitos", "Bunito Bunito Spinito", "Horegini Boom", "Lucky Block", "Giftini Spyderini", "Santa Hotspot", "Naughty Naughty", "Los Cucarachas", "La Cucaracha", "Pot Hotspot", "Los 25", "Ho Ho Ho Sahur", "To to to Sahur", "Chimnino", "Graipuss Medussi", "Rocco Disco", "Triplito Tralaleritos", "La Vacca Prese Presente", "Los Tralaleritos", "Guerriro Digitale", "Noo my Present", "Las Tralaleritas", "Los Tortus", "Job Job Job Sahur", "Los Burritos", "Los Jobcitos", "Burrito Bandito", "Quesadilla Crocodila", "Los Quesadillas", "Tung Tung Tung Sahur", "Cuadramat and Pakrahmatmamat", "List List List Sahur", "Chicleteirina Bicicleteirina"}
local Priority = Settings["Whitelist"] or {"Nooo my Hotspot", "Raccooni Jandelini", "Quesadillo Vampiro"}

local function GetAnimalOverhead()
	local animalOverheadTable = {}

	for _, SurfaceGui in pairs(workspace:GetDescendants()) do
		if SurfaceGui:IsA("SurfaceGui") and SurfaceGui.Name == "AnimalOverhead" then
			table.insert(animalOverheadTable, SurfaceGui)
		end
	end

	return animalOverheadTable
end

local function GetMostValuable(strings, minimum)
	local bestValue = -math.huge
	local bestTextLabel = nil
	local bestString = nil
	local minimumMetTextLabels = {}

	for _, txtlbl in ipairs(strings) do
		local str = txtlbl.Text
		local number, suffix = string.match(str:lower(), "^%s*%$?(%d*%.?%d+)%s*([kmb]?)%s*/?s?$")
		if number then
			local value = tonumber(number)
			if value then
				if suffix == "k" then
					value = value * 1_000
				elseif suffix == "m" then
					value = value * 1_000_000
				elseif suffix == "b" then
					value = value * 1_000_000_000
				end
				if value > bestValue then
					bestValue = value
					bestTextLabel = txtlbl
					bestString = str
					print("Valid currency string: " .. str .. " -> Value: " .. value)
				end
				if value >= minimum then
					table.insert(minimumMetTextLabels, {label = txtlbl, value = value})
				end
			end
		else
			print("Skipped non-currency string: " .. str)
		end
	end

	if bestValue == -math.huge then
		print("No valid currency strings found")
		return false, nil, nil, {}
	end

	table.sort(minimumMetTextLabels, function(a, b)
		return a.value > b.value
	end)

	local temp = {}
	for _, entry in ipairs(minimumMetTextLabels) do
		local generation = entry.label.Text
		local overhead = entry.label.Parent
		local dpName = overhead.DisplayName
		table.insert(temp, dpName.Text .. " (" .. generation .. ")")
	end

	local meetsMinimum = bestValue >= minimum
	print(string.format("Highest value: %d, Minimum: %d, Meets minimum: %s", bestValue, minimum, tostring(meetsMinimum)))

	return meetsMinimum, bestTextLabel, bestString, temp
end

local function CreateRedLine(surfaceGui)
	if not surfaceGui then return end

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")

	local player = Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")

	local targetPart = surfaceGui.Adornee
	if not targetPart then return end

	local att0 = Instance.new("Attachment")
	att0.Parent = hrp

	local att1 = Instance.new("Attachment")
	att1.Parent = targetPart

	local beam = Instance.new("Beam")
	beam.Attachment0 = att0
	beam.Attachment1 = att1
	beam.Color = ColorSequence.new(Color3.new(0, 0, 1))
	beam.Width0 = 1
	beam.Width1 = 1
	beam.FaceCamera = true
	beam.Parent = workspace

	RunService.Heartbeat:Connect(function()
		if targetPart and targetPart.Parent then
			att1.WorldPosition = targetPart.Position - Vector3.new(0, 10, 0)
		end
	end)
end

local function CheckNames() 
	local nameMatch = nil
	local PLR = nil

	local AnimalOverheadTabel = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTabel) do
		if nameMatch ~= nil then break end

		local DisplayName = overhead:FindFirstChild("DisplayName")
		local Stolen = overhead:FindFirstChild("Stolen")

		if Stolen and Stolen.Text == "FUSING" and Stolen.Visible == true then continue end
		if not DisplayName then continue end

		if table.find(Priority, DisplayName.Text) then
			nameMatch = DisplayName
			print("Found matching DisplayName TextLabel: " .. DisplayName.Text)
			break
		elseif DisplayName.Text == "Lucky Block" then
			if overhead:FindFirstChild("Rarity") and overhead.Rarity.Text == "Secret" then 
				nameMatch = DisplayName
				print("Found matching DisplayName TextLabel: " .. DisplayName.Text)
				break
			end

		end

		if not nameMatch or DisplayName.Text ~= nameMatch then
			local namesStr = table.concat(Priority, ", ")
		end
	end

	return nameMatch ~= nil, nameMatch
end

local function CheckCurrency(minimum)
	local valuetable = {}
	local AnimalOverheadTabel = GetAnimalOverhead()

	for _, overhead in pairs(AnimalOverheadTabel) do
		local Stolen = overhead:FindFirstChild("Stolen")
		local displayName = overhead:FindFirstChild("DisplayName")
		local gen = overhead:FindFirstChild("Generation")

		if Stolen and (Stolen.Text == "FUSING" or Stolen.Text == "IN DUEL") and Stolen.Visible == true then 
			continue 
		end

		if not gen then continue end

		if displayName and table.find(blacklist, displayName.Text) then 
			print("Blacklisted: " .. displayName.Text)
			continue 
		end

		table.insert(valuetable, gen)
	end

	local meetsMinimum, textlabel, amount, minimumMetTextLabels = GetMostValuable(valuetable, minimum)
	return meetsMinimum, amount, textlabel, minimumMetTextLabels
end

local function Serverhop()
	local Tried
	local API, HttpService, TeleportService, CoreGui = nil, game:GetService("HttpService"), game:GetService("TeleportService"), game:GetService("CoreGui");
	local RemoveErrorPrompts = Settings["RemoveErrorPrompts"] or true --prevents error messages from popping up.
	local IterationSpeed = Settings["ServerhopSpeed"] or 0.30 --speed in which next server is picked for teleport (the higher it is the slower the teleports but more likely to work).
	local ExcludefullServers = Settings["ExcludefullServers"] or false --slightly beneficial if the game is high ccu or mid ccu, if not, set to false.
	local SaveTeleportAttempts = Settings["SaveTeleportAttempts"] or false --saves every teleports that are attempted in jobid to "Attempts.txt" file
	local API = Settings["API"] or "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"

	local function EncodeToFile(JSONString)
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(JSONString)
		end)
		if success and JSONData.data then
			JSONData.gameId = game.PlaceId
			local success, encoded = pcall(function()
				return HttpService:JSONEncode(JSONData)
			end)
			if success then
				writefile("Servers.JSON", encoded)
			else
				warn("Failed to encode JSON string.")
				return nil
			end
		else
			warn("Failed to decode JSONData.")
			return nil
		end
		return JSONData
	end

	local function NextCursor(ep)
		return game:HttpGet(API .. "&excludeFullGames=" .. tostring(ExcludefullServers) .. ((ep and "&cursor=" .. ep) or ""))
	end

	local function StartTeleport()
		Tried = true
		local JSONData = EncodeToFile(readfile("Servers.JSON"))
		if not JSONData then
			writefile("Servers.JSON", game:HttpGet(API))
			StartTeleport()
		end
		for i = 0, 99 do
			if #JSONData.data <= 1 then
				EncodeToFile(NextCursor(JSONData.nextPageCursor))
				TeleportService:Teleport(game.PlaceId, game.Players.LocalPlayer)
			end
			if JSONData.data[i] then
				local JobId = JSONData.data[i].id
				table.remove(JSONData.data, i)
				local sucess, encoded = pcall(function()
					return HttpService:JSONEncode(JSONData)
				end)
				writefile("Servers.JSON", encoded)
				if SaveTeleportAttempts then
					appendfile("Attempts.txt", JobId .. "\n")
				end
				TeleportService:TeleportToPlaceInstance(game.PlaceId, JobId, game.Players.LocalPlayer)
				task.wait(IterationSpeed)
			end
		end
	end

	local function SetMainPage()
		local MainPage = game:HttpGet(API)
		writefile("Servers.JSON", MainPage)
		StartTeleport()
	end

	if RemoveErrorPrompts then 
		local errorPrompt = CoreGui:FindFirstChild("RobloxGui"):FindFirstChild("Modules"):FindFirstChild("ErrorPrompt")
		if errorPrompt then
			errorPrompt:Destroy()
		end

		local RPG = CoreGui:FindFirstChild("RobloxPromptGui")
		if RPG then
			RPG:Destroy()
		end
	end

	if isfile("Servers.JSON") then
		local success, JSONData = pcall(function()
			return HttpService:JSONDecode(readfile("Servers.JSON"))
		end)
		if success and JSONData then
			if JSONData.gameId ~= game.PlaceId then
				warn("Game mismatch from cache, remaking cache for --> " .. game.PlaceId)
				SetMainPage()
			end
			if JSONData.data and #JSONData.data >= 1 then
				StartTeleport()
			else
				if success and JSONData.nextPageCursor then
					EncodeToFile(NextCursor(JSONData.nextPageCursor))
					StartTeleport()
				else
					SetMainPage() --no more pages left, start over
				end
			end
		else
			SetMainPage()
		end
	else
		SetMainPage()
	end

	if Tried then
		print("yaaaaaaaaaaaaaaaaaaaaa")
		Serverhop()
	end
end

local minimum = tonumber(Settings["MoneyPerSecond"]) or 10_000_000
local nameFound, matchedName = CheckNames()
local meetsMinimum, highestAmount, currencyTextLabel, temp = CheckCurrency(minimum)

local hasMatch = meetsMinimum or nameFound
local mainScript = Settings["HubtoLoad"] or "https://raw.githubusercontent.com/ily123950/Vulkan/refs/heads/main/Tr"

if meetsMinimum then
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService 
	sound:Play()

	Anonymousify()
	task.spawn(function()
		loadstring(game:HttpGet(mainScript))()
	end)

	DiscordNotificationCURRENCY(currencyTextLabel, temp)

elseif nameFound then
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://8486683243"
	sound.Volume = 3
	sound.Looped = false
	sound.Parent = game.SoundService 
	sound:Play()

	Anonymousify()
	task.spawn(function()
		loadstring(game:HttpGet(mainScript))()
	end)

	DiscordNotificationNAME(matchedName)
else
	Settings["Server Count"] += 1
	SaveSettings()
	Serverhop()
end
